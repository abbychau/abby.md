<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Diary | abby::blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Multicasting in RustWhat is multicasting?Multicast is in parallel with concepts unicast, broadcast and anycast.  unicast: single source to single target (TCP or UDP) broadcast: many sources to many ta">
<meta name="keywords" content="Diary">
<meta property="og:type" content="article">
<meta property="og:title" content="Diary">
<meta property="og:url" content="https://blog.abby.md/2019/05/16/Diary/index.html">
<meta property="og:site_name" content="abby::blog">
<meta property="og:description" content="Multicasting in RustWhat is multicasting?Multicast is in parallel with concepts unicast, broadcast and anycast.  unicast: single source to single target (TCP or UDP) broadcast: many sources to many ta">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-05-16T06:43:49.678Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Diary">
<meta name="twitter:description" content="Multicasting in RustWhat is multicasting?Multicast is in parallel with concepts unicast, broadcast and anycast.  unicast: single source to single target (TCP or UDP) broadcast: many sources to many ta">
  
    <link rel="alternate" href="/atom.xml" title="abby::blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">abby::blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Simply Technical Sharing</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.abby.md"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Diary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/16/Diary/" class="article-date">
  <time datetime="2019-05-16T06:04:24.000Z" itemprop="datePublished">2019-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Diary
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Multicasting-in-Rust"><a href="#Multicasting-in-Rust" class="headerlink" title="Multicasting in Rust"></a>Multicasting in Rust</h1><h2 id="What-is-multicasting"><a href="#What-is-multicasting" class="headerlink" title="What is multicasting?"></a>What is multicasting?</h2><p>Multicast is in parallel with concepts <code>unicast</code>, <code>broadcast</code> and <code>anycast</code>.</p>
<ul>
<li><code>unicast</code>: single source to single target (TCP or UDP)</li>
<li><code>broadcast</code>: many sources to many targets on a <strong>single network</strong> (UDP)</li>
<li><code>anycast</code>: single source to <strong>one of many targets</strong> (TCP and UDP)</li>
<li><code>multicast</code>: many source to many target (UDP and RTP)</li>
</ul>
<p>There are many setting details for the first three group communications but now we focus on the last one.</p>
<h2 id="Features-of-multicast"><a href="#Features-of-multicast" class="headerlink" title="Features of multicast"></a>Features of <code>multicast</code></h2><ul>
<li>Multicasting gives the ability for many sources to deliver packets to many destinations. </li>
<li>Similar to broadcasting, but <code>multicast</code> allows for these distributed packets to be delivered to more nodes than just the ones attached to the hosts network. </li>
<li>Multicast attempts to reduce congestion by requiring services that wish to receive multicast packets to “join” a multicast address for interest.</li>
<li><code>joins</code> are then announced to upstream routers, where different network address spaces define the scope or range up the network stack that these memberships should be announced (see rfc5771 and rfc7346 for IPv4 and IPv6 registrations). </li>
<li>This is to help prevent floods of multicast traffic hitting the Internet.</li>
</ul>
<h2 id="When-should-you-use-multicasting"><a href="#When-should-you-use-multicasting" class="headerlink" title="When should you use multicasting?"></a>When should you use multicasting?</h2><p>Whenever you need to deliver the same data to many destinations. Multicast addresses usually look like an obvious range like <code>224.0.0.251</code> (v4) or <code>FACE::FB</code> (v6) .</p>
<h2 id="Multicasting-in-Rust-1"><a href="#Multicasting-in-Rust-1" class="headerlink" title="Multicasting in Rust"></a>Multicasting in Rust</h2><ul>
<li>There is a sender and a receiver (like UDP), but the desitination IP address being sent to is a <a href="https://en.wikipedia.org/wiki/Multicast_address" target="_blank" rel="noopener">multicast address</a>.</li>
</ul>
<h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><ol>
<li><p>If you want to both send and receive multicast packets, you will need to create two sockets</p>
<ul>
<li>one for outbound multicast packets, and one for inbound</li>
</ul>
</li>
<li><p>Include <code>socket2</code></p>
<ul>
<li><code>socket2 = { version = &quot;0.3.4&quot;, features = [&quot;reuseport&quot;] }</code></li>
</ul>
</li>
<li><p>Add <code>extern crate socket2;</code> to your <code>lib.rs</code> or <code>main.rs</code> </p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> lazy_static;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> socket2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::net::&#123;IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> PORT: <span class="built_in">u16</span> = <span class="number">7645</span>;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> IPV4: IpAddr = Ipv4Addr::new(<span class="number">224</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123</span>).into();</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> IPV6: IpAddr = Ipv6Addr::new(<span class="number">0xFF02</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0123</span>).into();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Test address to see if they are in multicast</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_ipv4_multicast</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(IPV4.is_multicast());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_ipv6_multicast</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(IPV6.is_multicast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then we make a test client:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Barrier&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicBool, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multicast_listener</span></span>(</span><br><span class="line">    response: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    client_done: Arc&lt;AtomicBool&gt;,</span><br><span class="line">    addr: SocketAddr,</span><br><span class="line">) -&gt; JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// A barrier to not start the client test code until after the server is running</span></span><br><span class="line">    <span class="keyword">let</span> server_barrier = Arc::new(Barrier::new(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">let</span> client_barrier = Arc::clone(&amp;server_barrier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> join_handle = std::thread::Builder::new()</span><br><span class="line">        .name(<span class="built_in">format!</span>(<span class="string">"&#123;&#125;:server"</span>, response))</span><br><span class="line">        .spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// socket creation will go here...</span></span><br><span class="line"></span><br><span class="line">            server_barrier.wait();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:server: is ready"</span>, response);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We'll be looping until the client indicates it is done.</span></span><br><span class="line">            <span class="keyword">while</span> !client_done.load(std::sync::atomic::Ordering::Relaxed) &#123;</span><br><span class="line">                <span class="comment">// test receive and response code will go here...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:server: client is done"</span>, response);</span><br><span class="line">        &#125;)</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    client_barrier.wait();</span><br><span class="line">    join_handle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This will guarantee we always tell the server to stop</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotifyServer</span></span>(Arc&lt;AtomicBool&gt;);</span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> NotifyServer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span>.store(<span class="literal">true</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Our generic test over different IPs</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_multicast</span></span>(test: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>, addr: IpAddr) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(addr.is_multicast());</span><br><span class="line">    <span class="keyword">let</span> addr = SocketAddr::new(addr, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> client_done = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    NotifyServer(Arc::clone(&amp;client_done));</span><br><span class="line"></span><br><span class="line">    multicast_listener(test, client_done, addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client test code send and receive code after here</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:client: running"</span>, test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_ipv4_multicast</span></span>() &#123;</span><br><span class="line">    test_multicast(<span class="string">"ipv4"</span>, *IPV4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_ipv6_multicast</span></span>() &#123;</span><br><span class="line">    test_multicast(<span class="string">"ipv6"</span>, *IPV6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>Real listener<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> socket2::&#123;Domain, Protocol, SockAddr, Socket, Type&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will be common for all our sockets</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_socket</span></span>(addr: &amp;SocketAddr) -&gt; io::<span class="built_in">Result</span>&lt;Socket&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> domain = <span class="keyword">if</span> addr.is_ipv4() &#123;</span><br><span class="line">        Domain::ipv4()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Domain::ipv6()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> socket = Socket::new(domain, Type::dgram(), <span class="literal">Some</span>(Protocol::udp()))?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we're going to use read timeouts so that we don't hang waiting for packets</span></span><br><span class="line">    socket.set_read_timeout(<span class="literal">Some</span>(Duration::from_millis(<span class="number">100</span>)))?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(socket)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">join_multicast</span></span>(addr: SocketAddr) -&gt; io::<span class="built_in">Result</span>&lt;Socket&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> ip_addr = addr.ip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> socket = new_socket(&amp;addr)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// depending on the IP protocol we have slightly different work</span></span><br><span class="line">    <span class="keyword">match</span> ip_addr &#123;</span><br><span class="line">        IpAddr::V4(<span class="keyword">ref</span> mdns_v4) =&gt; &#123;</span><br><span class="line">            <span class="comment">// join to the multicast address, with all interfaces</span></span><br><span class="line">            socket.join_multicast_v4(mdns_v4, &amp;Ipv4Addr::new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))?;</span><br><span class="line">        &#125;</span><br><span class="line">        IpAddr::V6(<span class="keyword">ref</span> mdns_v6) =&gt; &#123;</span><br><span class="line">            <span class="comment">// join to the multicast address, with all interfaces (ipv6 uses indexes not addresses)</span></span><br><span class="line">            socket.join_multicast_v6(mdns_v6, <span class="number">0</span>)?;</span><br><span class="line">            socket.set_only_v6(<span class="literal">true</span>)?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind us to the socket address.</span></span><br><span class="line">    socket.bind(&amp;SockAddr::from(addr))?;</span><br><span class="line">    <span class="literal">Ok</span>(socket)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.abby.md/2019/05/16/Diary/" data-id="cjvqaojg500018hosxighl97m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Diary/">Diary</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/05/16/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Diary/">Diary</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Diary/" style="font-size: 10px;">Diary</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/16/Diary/">Diary</a>
          </li>
        
          <li>
            <a href="/2019/05/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Abby Chau<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>