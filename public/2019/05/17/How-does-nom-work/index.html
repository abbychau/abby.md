<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>How does nom v.5 work? | abby::blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="What is nom?nom is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensive">
<meta name="keywords" content="nom,Rust,parser,json,nom5">
<meta property="og:type" content="article">
<meta property="og:title" content="How does nom v.5 work?">
<meta property="og:url" content="https://blog.abby.md/2019/05/17/How-does-nom-work/index.html">
<meta property="og:site_name" content="abby::blog">
<meta property="og:description" content="What is nom?nom is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensive">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-05-17T08:11:52.150Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How does nom v.5 work?">
<meta name="twitter:description" content="What is nom?nom is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensive">
  
    <link rel="alternate" href="/atom.xml" title="abby::blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">abby::blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Simply Technical Sharing</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.abby.md"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-How-does-nom-work" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/17/How-does-nom-work/" class="article-date">
  <time datetime="2019-05-17T00:24:58.000Z" itemprop="datePublished">2019-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      How does nom v.5 work?
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="What-is-nom"><a href="#What-is-nom" class="headerlink" title="What is nom?"></a>What is nom?</h2><p><code>nom</code> is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensively Rustâ€™s strong typing and memory safety to produce fast and correct parsers, and provides functions, macros and traits to abstract most of the error prone plumbing.</p>
<h2 id="Why-this-passage"><a href="#Why-this-passage" class="headerlink" title="Why this passage?"></a>Why this passage?</h2><p><code>nom</code> version 5 is going through a very large change to the lexical syntax to be used. The old way will not work any more. So this passage will tell and explain the new way.</p>
<h2 id="Hello-Color"><a href="#Hello-Color" class="headerlink" title="Hello Color"></a>Hello Color</h2><p>This is a hello world example for parser that we are going to parse Hex color like <code>#2F14DF</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> nom;</span><br><span class="line"><span class="keyword">use</span> nom::&#123;</span><br><span class="line">  IResult,</span><br><span class="line">  bytes::complete::&#123;tag, take_while_m_n&#125;,</span><br><span class="line">  combinator::map_res,</span><br><span class="line">  sequence::tuple</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug,PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> red:   <span class="built_in">u8</span>,</span><br><span class="line">  <span class="keyword">pub</span> green: <span class="built_in">u8</span>,</span><br><span class="line">  <span class="keyword">pub</span> blue:  <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">from_hex</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u8</span>, std::num::ParseIntError&gt; &#123;</span><br><span class="line">  <span class="built_in">u8</span>::from_str_radix(input, <span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_hex_digit</span></span>(c: <span class="built_in">char</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  c.is_digit(<span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hex_primary</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; IResult&lt;&amp;<span class="built_in">str</span>, <span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">  map_res(</span><br><span class="line">    take_while_m_n(<span class="number">2</span>, <span class="number">2</span>, is_hex_digit),</span><br><span class="line">    from_hex</span><br><span class="line">  )(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hex_color</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; IResult&lt;&amp;<span class="built_in">str</span>, Color&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (input, _) = tag(<span class="string">"#"</span>)(input)?;</span><br><span class="line">  <span class="keyword">let</span> (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;</span><br><span class="line"></span><br><span class="line">  <span class="literal">Ok</span>((input, Color &#123; red, green, blue &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_color</span></span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(hex_color(<span class="string">"#2F14DF"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, Color &#123;</span><br><span class="line">    red: <span class="number">47</span>,</span><br><span class="line">    green: <span class="number">20</span>,</span><br><span class="line">    blue: <span class="number">223</span>,</span><br><span class="line">  &#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The combinator is writting in a very functional way.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (input, _) = tag(<span class="string">"#"</span>)(input)?;</span><br><span class="line"><span class="keyword">let</span> (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>((input, Color &#123; red, green, blue &#125;))</span><br></pre></td></tr></table></figure>
<p>That, <code>tag(&quot;#&quot;)</code>, <code>tuple((hex_primary, hex_primary, hex_primary))</code> are functions.</p>
<h2 id="Parse-Json"><a href="#Parse-Json" class="headerlink" title="Parse Json"></a>Parse Json</h2><p>Then we come to the real world. They provided a very efficient Json parser as an example of nom.</p>
<p>Please find the example <a href="https://github.com/Geal/nom/blob/master/examples/json.rs" target="_blank" rel="noopener">here</a>.</p>
<p>Revision, this is the defination or state-machine of Json.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">JsonValue</span></span> &#123;</span><br><span class="line">  Str(<span class="built_in">String</span>),</span><br><span class="line">  Boolean(<span class="built_in">bool</span>),</span><br><span class="line">  Num(<span class="built_in">f64</span>),</span><br><span class="line">  Array(<span class="built_in">Vec</span>&lt;JsonValue&gt;),</span><br><span class="line">  Object(HashMap&lt;<span class="built_in">String</span>, JsonValue&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following are lexical elements:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sp</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> chars = <span class="string">" \t\r\n"</span>;</span><br><span class="line"></span><br><span class="line">  take_while(<span class="keyword">move</span> |c| chars.contains(c))(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Space should be obvious.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">float</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">f64</span>, E&gt; &#123;</span><br><span class="line">  flat_map!(i, recognize_float, parse_to!(<span class="built_in">f64</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nom provided features <code>recognize_float</code> and <code>parse_to</code> to do it automatically.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_str</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">    escaped!(i, call!(alphanumeric), <span class="string">'\\'</span>, one_of!(<span class="string">"\"n\\"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call!()</code> is a macro to call a named function as callback. It can also take in argument like below.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_wrapper</span></span>(input: &amp;[<span class="built_in">u8</span>], i: <span class="built_in">u8</span>) -&gt; IResult&lt;&amp;[<span class="built_in">u8</span>], &amp;[<span class="built_in">u8</span>]&gt; &#123; take!(input, i * <span class="number">10</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// will make a parser taking 20 bytes</span></span><br><span class="line">named!(parser, call!(take_wrapper, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>For <code>one_of!()</code>:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(simple&lt;<span class="built_in">char</span>&gt;, one_of!(&amp;<span class="string">b"abc"</span>[..]));</span><br><span class="line"><span class="built_in">assert_eq!</span>(simple(<span class="string">b"a123"</span>), <span class="literal">Ok</span>((&amp;<span class="string">b"123"</span>[..], <span class="string">'a'</span>)));</span><br><span class="line"></span><br><span class="line">named!(a_or_b&lt;&amp;<span class="built_in">str</span>, <span class="built_in">char</span>&gt;, one_of!(<span class="string">"abæ±‰"</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(a_or_b(<span class="string">"æ±‰jiosfe"</span>), <span class="literal">Ok</span>((<span class="string">"jiosfe"</span>, <span class="string">'æ±‰'</span>)));</span><br></pre></td></tr></table></figure></p>
<p>This following code will extract string lexical elements by <code>{&quot;...&quot;}</code>. We can see that delimiters actually helps programmer to write parsers.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'\"'</span>)(i)?;</span><br><span class="line">  context(<span class="string">"string"</span>, terminated(parse_str, <span class="built_in">char</span>(<span class="string">'\"'</span>)))(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Boolean is a simple tag.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">boolean</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(input: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">bool</span>, E&gt; &#123;</span><br><span class="line">  alt( (</span><br><span class="line">      |i| tag(<span class="string">"false"</span>)(i).map(|(i,_)| (i, <span class="literal">false</span>)),</span><br><span class="line">      |i| tag(<span class="string">"true"</span>)(i).map(|(i,_)| (i, <span class="literal">true</span>))</span><br><span class="line">  ))(input)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">array</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">Vec</span>&lt;JsonValue&gt;, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'['</span>)(i)?;</span><br><span class="line"></span><br><span class="line">  context(</span><br><span class="line">    <span class="string">"array"</span>,</span><br><span class="line">    terminated(</span><br><span class="line">      |i| separated_listc(i, preceded(sp, <span class="built_in">char</span>(<span class="string">','</span>)), value),</span><br><span class="line">      preceded(sp, <span class="built_in">char</span>(<span class="string">']'</span>)))</span><br><span class="line">     )(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">key_value</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, (&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, JsonValue), E&gt; &#123;</span><br><span class="line">  separated_pair!(i, preceded!(sp, string), preceded!(sp, char!(<span class="string">':'</span>)), value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>preceded</code> is a tool to check if defined something is following.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(parser&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;, preceded!(char!(<span class="string">'-'</span>), alpha1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"-abc"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, <span class="string">"abc"</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"abc"</span>, ErrorKind::Char))));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"-123"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"123"</span>, ErrorKind::Alpha))));</span><br></pre></td></tr></table></figure>
<p><code>separated_list</code> is a string <code>split</code> in native Rust (or other languages).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hash</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, HashMap&lt;<span class="built_in">String</span>, JsonValue&gt;, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'&#123;'</span>)(i)?;</span><br><span class="line">  context(</span><br><span class="line">    <span class="string">"map"</span>,</span><br><span class="line">    terminated(</span><br><span class="line">      |i| map!(i,</span><br><span class="line">        separated_list!(preceded!(sp, char!(<span class="string">','</span>)), key_value),</span><br><span class="line">        |tuple_vec| tuple_vec</span><br><span class="line">          .into_iter()</span><br><span class="line">          .map(|(k, v)| (<span class="built_in">String</span>::from(k), v))</span><br><span class="line">          .collect()</span><br><span class="line">      ),</span><br><span class="line">      preceded(sp, <span class="built_in">char</span>(<span class="string">'&#125;'</span>)))</span><br><span class="line">     )(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>terminated()!</code> returns the result of its first parser if both succeed</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(parser&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;, terminated!(alpha1, char!(<span class="string">';'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc;"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, <span class="string">"abc"</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc,"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">","</span>, ErrorKind::Char))));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"123;"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"123;"</span>, ErrorKind::Alpha))));</span><br></pre></td></tr></table></figure>
<p>and it also takes the third parameter which is a callback like the second parameter in nom 4.3.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map!(i,</span><br><span class="line">    separated_list!(preceded!(sp, char!(<span class="string">','</span>)), key_value),</span><br><span class="line">    |tuple_vec| tuple_vec</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|(k, v)| (<span class="built_in">String</span>::from(k), v))</span><br><span class="line">        .collect()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>At the end:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, JsonValue, E&gt; &#123;</span><br><span class="line">  preceded!(i,</span><br><span class="line">    sp,</span><br><span class="line">    alt!(</span><br><span class="line">      hash    =&gt; &#123; |h| JsonValue::Object(h)            &#125; |</span><br><span class="line">      array   =&gt; &#123; |v| JsonValue::Array(v)             &#125; |</span><br><span class="line">      string  =&gt; &#123; |s| JsonValue::Str(<span class="built_in">String</span>::from(s)) &#125; |</span><br><span class="line">      float   =&gt; &#123; |f| JsonValue::Num(f)               &#125; |</span><br><span class="line">      boolean =&gt; &#123; |b| JsonValue::Boolean(b)           &#125;</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alt</code> try a list of parsers and return the result of the first successful one.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.abby.md/2019/05/17/How-does-nom-work/" data-id="cjvrt1daa0000bcos668d9p7u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nom-Rust-parser-json-nom5/">nom,Rust,parser,json,nom5</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/05/16/multicasting-in-rust/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Multicasting in Rust</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust-ipv4-ipv6-multicast-udp/">Rust,ipv4,ipv6,multicast,udp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nom-Rust-parser-json-nom5/">nom,Rust,parser,json,nom5</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Rust-ipv4-ipv6-multicast-udp/" style="font-size: 10px;">Rust,ipv4,ipv6,multicast,udp</a> <a href="/tags/nom-Rust-parser-json-nom5/" style="font-size: 10px;">nom,Rust,parser,json,nom5</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/17/How-does-nom-work/">How does nom v.5 work?</a>
          </li>
        
          <li>
            <a href="/2019/05/16/multicasting-in-rust/">Multicasting in Rust</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Abby Chau<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>