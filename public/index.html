<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>abby::blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Sharing different computer parts">
<meta name="keywords" content="Programming,abbychau,blog,PHP,Rust">
<meta property="og:type" content="website">
<meta property="og:title" content="abby::blog">
<meta property="og:url" content="https://blog.abby.md/index.html">
<meta property="og:site_name" content="abby::blog">
<meta property="og:description" content="Sharing different computer parts">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="abby::blog">
<meta name="twitter:description" content="Sharing different computer parts">
  
    <link rel="alternate" href="/atom.xml" title="abby::blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">abby::blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Simply Technical Sharing</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.abby.md"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-How-does-nom-work" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/17/How-does-nom-work/" class="article-date">
  <time datetime="2019-05-17T00:24:58.000Z" itemprop="datePublished">2019-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/17/How-does-nom-work/">How does nom v.5 work?</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="What-is-nom"><a href="#What-is-nom" class="headerlink" title="What is nom?"></a>What is nom?</h2><p><code>nom</code> is a parser combinators library written in Rust. Its goal is to provide tools to build safe parsers without compromising the speed or memory consumption. To that end, it uses extensively Rust’s strong typing and memory safety to produce fast and correct parsers, and provides functions, macros and traits to abstract most of the error prone plumbing.</p>
<h2 id="Why-this-passage"><a href="#Why-this-passage" class="headerlink" title="Why this passage?"></a>Why this passage?</h2><p><code>nom</code> version 5 is going through a very large change to the lexical syntax to be used. The old way will not work any more. So this passage will tell and explain the new way.</p>
<h2 id="Hello-Color"><a href="#Hello-Color" class="headerlink" title="Hello Color"></a>Hello Color</h2><p>This is a hello world example for parser that we are going to parse Hex color like <code>#2F14DF</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> nom;</span><br><span class="line"><span class="keyword">use</span> nom::&#123;</span><br><span class="line">  IResult,</span><br><span class="line">  bytes::complete::&#123;tag, take_while_m_n&#125;,</span><br><span class="line">  combinator::map_res,</span><br><span class="line">  sequence::tuple</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug,PartialEq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">  <span class="keyword">pub</span> red:   <span class="built_in">u8</span>,</span><br><span class="line">  <span class="keyword">pub</span> green: <span class="built_in">u8</span>,</span><br><span class="line">  <span class="keyword">pub</span> blue:  <span class="built_in">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">from_hex</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">u8</span>, std::num::ParseIntError&gt; &#123;</span><br><span class="line">  <span class="built_in">u8</span>::from_str_radix(input, <span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_hex_digit</span></span>(c: <span class="built_in">char</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">  c.is_digit(<span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hex_primary</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; IResult&lt;&amp;<span class="built_in">str</span>, <span class="built_in">u8</span>&gt; &#123;</span><br><span class="line">  map_res(</span><br><span class="line">    take_while_m_n(<span class="number">2</span>, <span class="number">2</span>, is_hex_digit),</span><br><span class="line">    from_hex</span><br><span class="line">  )(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hex_color</span></span>(input: &amp;<span class="built_in">str</span>) -&gt; IResult&lt;&amp;<span class="built_in">str</span>, Color&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (input, _) = tag(<span class="string">"#"</span>)(input)?;</span><br><span class="line">  <span class="keyword">let</span> (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;</span><br><span class="line"></span><br><span class="line">  <span class="literal">Ok</span>((input, Color &#123; red, green, blue &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_color</span></span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(hex_color(<span class="string">"#2F14DF"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, Color &#123;</span><br><span class="line">    red: <span class="number">47</span>,</span><br><span class="line">    green: <span class="number">20</span>,</span><br><span class="line">    blue: <span class="number">223</span>,</span><br><span class="line">  &#125;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The combinator is writting in a very functional way.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (input, _) = tag(<span class="string">"#"</span>)(input)?;</span><br><span class="line"><span class="keyword">let</span> (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;</span><br><span class="line"></span><br><span class="line"><span class="literal">Ok</span>((input, Color &#123; red, green, blue &#125;))</span><br></pre></td></tr></table></figure>
<p>That, <code>tag(&quot;#&quot;)</code>, <code>tuple((hex_primary, hex_primary, hex_primary))</code> are functions.</p>
<h2 id="Parse-Json"><a href="#Parse-Json" class="headerlink" title="Parse Json"></a>Parse Json</h2><p>Then we come to the real world. They provided a very efficient Json parser as an example of nom.</p>
<p>Please find the example <a href="https://github.com/Geal/nom/blob/master/examples/json.rs" target="_blank" rel="noopener">here</a>.</p>
<p>Revision, this is the defination or state-machine of Json.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">JsonValue</span></span> &#123;</span><br><span class="line">  Str(<span class="built_in">String</span>),</span><br><span class="line">  Boolean(<span class="built_in">bool</span>),</span><br><span class="line">  Num(<span class="built_in">f64</span>),</span><br><span class="line">  Array(<span class="built_in">Vec</span>&lt;JsonValue&gt;),</span><br><span class="line">  Object(HashMap&lt;<span class="built_in">String</span>, JsonValue&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following are lexical elements:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sp</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> chars = <span class="string">" \t\r\n"</span>;</span><br><span class="line"></span><br><span class="line">  take_while(<span class="keyword">move</span> |c| chars.contains(c))(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Space should be obvious.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">float</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">f64</span>, E&gt; &#123;</span><br><span class="line">  flat_map!(i, recognize_float, parse_to!(<span class="built_in">f64</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nom provided features <code>recognize_float</code> and <code>parse_to</code> to do it automatically.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">parse_str</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">    escaped!(i, call!(alphanumeric), <span class="string">'\\'</span>, one_of!(<span class="string">"\"n\\"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>call!()</code> is a macro to call a named function as callback. It can also take in argument like below.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_wrapper</span></span>(input: &amp;[<span class="built_in">u8</span>], i: <span class="built_in">u8</span>) -&gt; IResult&lt;&amp;[<span class="built_in">u8</span>], &amp;[<span class="built_in">u8</span>]&gt; &#123; take!(input, i * <span class="number">10</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// will make a parser taking 20 bytes</span></span><br><span class="line">named!(parser, call!(take_wrapper, <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>For <code>one_of!()</code>:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(simple&lt;<span class="built_in">char</span>&gt;, one_of!(&amp;<span class="string">b"abc"</span>[..]));</span><br><span class="line"><span class="built_in">assert_eq!</span>(simple(<span class="string">b"a123"</span>), <span class="literal">Ok</span>((&amp;<span class="string">b"123"</span>[..], <span class="string">'a'</span>)));</span><br><span class="line"></span><br><span class="line">named!(a_or_b&lt;&amp;<span class="built_in">str</span>, <span class="built_in">char</span>&gt;, one_of!(<span class="string">"ab汉"</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(a_or_b(<span class="string">"汉jiosfe"</span>), <span class="literal">Ok</span>((<span class="string">"jiosfe"</span>, <span class="string">'汉'</span>)));</span><br></pre></td></tr></table></figure></p>
<p>This following code will extract string lexical elements by <code>{&quot;...&quot;}</code>. We can see that delimiters actually helps programmer to write parsers.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">string</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'\"'</span>)(i)?;</span><br><span class="line">  context(<span class="string">"string"</span>, terminated(parse_str, <span class="built_in">char</span>(<span class="string">'\"'</span>)))(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Boolean is a simple tag.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">boolean</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(input: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">bool</span>, E&gt; &#123;</span><br><span class="line">  alt( (</span><br><span class="line">      |i| tag(<span class="string">"false"</span>)(i).map(|(i,_)| (i, <span class="literal">false</span>)),</span><br><span class="line">      |i| tag(<span class="string">"true"</span>)(i).map(|(i,_)| (i, <span class="literal">true</span>))</span><br><span class="line">  ))(input)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">array</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, <span class="built_in">Vec</span>&lt;JsonValue&gt;, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'['</span>)(i)?;</span><br><span class="line"></span><br><span class="line">  context(</span><br><span class="line">    <span class="string">"array"</span>,</span><br><span class="line">    terminated(</span><br><span class="line">      |i| separated_listc(i, preceded(sp, <span class="built_in">char</span>(<span class="string">','</span>)), value),</span><br><span class="line">      preceded(sp, <span class="built_in">char</span>(<span class="string">']'</span>)))</span><br><span class="line">     )(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">key_value</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, (&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, JsonValue), E&gt; &#123;</span><br><span class="line">  separated_pair!(i, preceded!(sp, string), preceded!(sp, char!(<span class="string">':'</span>)), value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>preceded</code> is a tool to check if defined something is following.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(parser&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;, preceded!(char!(<span class="string">'-'</span>), alpha1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"-abc"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, <span class="string">"abc"</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"abc"</span>, ErrorKind::Char))));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"-123"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"123"</span>, ErrorKind::Alpha))));</span><br></pre></td></tr></table></figure>
<p><code>separated_list</code> is a string <code>split</code> in native Rust (or other languages).</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hash</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, HashMap&lt;<span class="built_in">String</span>, JsonValue&gt;, E&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> (i, _) = <span class="built_in">char</span>(<span class="string">'&#123;'</span>)(i)?;</span><br><span class="line">  context(</span><br><span class="line">    <span class="string">"map"</span>,</span><br><span class="line">    terminated(</span><br><span class="line">      |i| map!(i,</span><br><span class="line">        separated_list!(preceded!(sp, char!(<span class="string">','</span>)), key_value),</span><br><span class="line">        |tuple_vec| tuple_vec</span><br><span class="line">          .into_iter()</span><br><span class="line">          .map(|(k, v)| (<span class="built_in">String</span>::from(k), v))</span><br><span class="line">          .collect()</span><br><span class="line">      ),</span><br><span class="line">      preceded(sp, <span class="built_in">char</span>(<span class="string">'&#125;'</span>)))</span><br><span class="line">     )(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>terminated()!</code> returns the result of its first parser if both succeed</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">named!(parser&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;, terminated!(alpha1, char!(<span class="string">';'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc;"</span>), <span class="literal">Ok</span>((<span class="string">""</span>, <span class="string">"abc"</span>)));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"abc,"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">","</span>, ErrorKind::Char))));</span><br><span class="line"><span class="built_in">assert_eq!</span>(parser(<span class="string">"123;"</span>), <span class="literal">Err</span>(Err::Error((<span class="string">"123;"</span>, ErrorKind::Alpha))));</span><br></pre></td></tr></table></figure>
<p>and it also takes the third parameter which is a callback like the second parameter in nom 4.3.<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map!(i,</span><br><span class="line">    separated_list!(preceded!(sp, char!(<span class="string">','</span>)), key_value),</span><br><span class="line">    |tuple_vec| tuple_vec</span><br><span class="line">        .into_iter()</span><br><span class="line">        .map(|(k, v)| (<span class="built_in">String</span>::from(k), v))</span><br><span class="line">        .collect()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>At the end:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>&lt;<span class="symbol">'a</span>, E: ParseError&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>&gt;&gt;(i: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt;IResult&lt;&amp;<span class="symbol">'a</span> <span class="built_in">str</span>, JsonValue, E&gt; &#123;</span><br><span class="line">  preceded!(i,</span><br><span class="line">    sp,</span><br><span class="line">    alt!(</span><br><span class="line">      hash    =&gt; &#123; |h| JsonValue::Object(h)            &#125; |</span><br><span class="line">      array   =&gt; &#123; |v| JsonValue::Array(v)             &#125; |</span><br><span class="line">      string  =&gt; &#123; |s| JsonValue::Str(<span class="built_in">String</span>::from(s)) &#125; |</span><br><span class="line">      float   =&gt; &#123; |f| JsonValue::Num(f)               &#125; |</span><br><span class="line">      boolean =&gt; &#123; |b| JsonValue::Boolean(b)           &#125;</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alt</code> try a list of parsers and return the result of the first successful one.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.abby.md/2019/05/17/How-does-nom-work/" data-id="cjvrt1daa0000bcos668d9p7u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nom-Rust-parser-json-nom5/">nom,Rust,parser,json,nom5</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-multicasting-in-rust" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/16/multicasting-in-rust/" class="article-date">
  <time datetime="2019-05-16T06:04:24.000Z" itemprop="datePublished">2019-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/16/multicasting-in-rust/">Multicasting in Rust</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="What-is-multicasting"><a href="#What-is-multicasting" class="headerlink" title="What is multicasting?"></a>What is multicasting?</h2><p>Multicast is in parallel with concepts <code>unicast</code>, <code>broadcast</code> and <code>anycast</code>.</p>
<ul>
<li><code>unicast</code>: single source to single target (TCP or UDP)</li>
<li><code>broadcast</code>: many sources to many targets on a <strong>single network</strong> (UDP)</li>
<li><code>anycast</code>: single source to <strong>one of many targets</strong> (TCP and UDP)</li>
<li><code>multicast</code>: many source to many target (UDP and RTP)</li>
</ul>
<p>There are many setting details for the first three group communications but now we focus on the last one.</p>
<h2 id="Features-of-multicast"><a href="#Features-of-multicast" class="headerlink" title="Features of multicast"></a>Features of <code>multicast</code></h2><ul>
<li>Multicasting gives the ability for many sources to deliver packets to many destinations. </li>
<li>Similar to broadcasting, but <code>multicast</code> allows for these distributed packets to be delivered to more nodes than just the ones attached to the hosts network. </li>
<li>Multicast attempts to reduce congestion by requiring services that wish to receive multicast packets to “join” a multicast address for interest.</li>
<li><code>joins</code> are then announced to upstream routers, where different network address spaces define the scope or range up the network stack that these memberships should be announced (see rfc5771 and rfc7346 for IPv4 and IPv6 registrations). </li>
<li>This is to help prevent floods of multicast traffic hitting the Internet.</li>
</ul>
<h2 id="When-should-you-use-multicasting"><a href="#When-should-you-use-multicasting" class="headerlink" title="When should you use multicasting?"></a>When should you use multicasting?</h2><p>Whenever you need to deliver the same data to many destinations. Multicast addresses usually look like an obvious range like <code>224.0.0.251</code> (v4) or <code>FACE::FB</code> (v6) .</p>
<h2 id="Multicasting-in-Rust"><a href="#Multicasting-in-Rust" class="headerlink" title="Multicasting in Rust"></a>Multicasting in Rust</h2><ul>
<li>There is a sender and a receiver (like UDP), but the desitination IP address being sent to is a <a href="https://en.wikipedia.org/wiki/Multicast_address" target="_blank" rel="noopener">multicast address</a>.</li>
</ul>
<table>
<thead>
<tr>
<th>D类地址</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>224.0.0.1</td>
<td>在一个子网上的所有主机</td>
</tr>
<tr>
<td>224.0.0.2</td>
<td>在一个子网上的所有路由器</td>
</tr>
<tr>
<td>224.0.0.4</td>
<td>所有DVMRP协议的路由器</td>
</tr>
<tr>
<td>224.0.0.5</td>
<td>所有开放最短路径优先（OSPF）路由器</td>
</tr>
<tr>
<td>224.0.0.6</td>
<td>所有OSPF指定路由器</td>
</tr>
<tr>
<td>224.0.0.9</td>
<td>所有RIPv2路由器</td>
</tr>
<tr>
<td>224.0.0.13</td>
<td>所有PIM协议路由器</td>
</tr>
<tr>
<td>224.0.0.0-224.0.0.255</td>
<td>保留作本地使用，做管理和维护任务</td>
</tr>
<tr>
<td>239.0.0.0-239.255.255.255</td>
<td>留用做管理使用</td>
</tr>
</tbody>
</table>
<h2 id="Coding-Example"><a href="#Coding-Example" class="headerlink" title="Coding Example"></a>Coding Example</h2><p>This example is using the <code>std::net::UdpSocket</code></p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::UdpSocket;</span><br><span class="line"><span class="keyword">use</span> std::net::Ipv4Addr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> socket = UdpSocket::bind(<span class="string">"0.0.0.0:8888"</span>).unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0u8</span>; <span class="number">65535</span>];</span><br><span class="line">    <span class="keyword">let</span> multi_addr = Ipv4Addr::new(<span class="number">234</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> inter = Ipv4Addr::new(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    socket.join_multicast_v4(&amp;multi_addr,&amp;inter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> (amt, src) = socket.recv_from(&amp;<span class="keyword">mut</span> buf).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"received &#123;&#125; bytes from &#123;:?&#125;"</span>, amt, src);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::UdpSocket;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> socket = UdpSocket::bind(<span class="string">"0.0.0.0:9999"</span>).unwrap();</span><br><span class="line">    <span class="keyword">let</span> buf = [<span class="number">1u8</span>; <span class="number">15000</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">1473</span>;</span><br><span class="line">    socket.send_to(&amp;buf[<span class="number">0</span>..count], <span class="string">"234.2.2.2:8888"</span>).unwrap();</span><br><span class="line"></span><br><span class="line">    thread::sleep_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h2><p><code>std::net::UdpSocket</code> is actually not providing all options from <code>libc</code>. <code>socket2</code> provide them.</p>
<p>Let’s have a look on <a href="https://github.com/bluejekyll/multicast-example/blob/master/src/lib.rs" target="_blank" rel="noopener">this example</a>.</p>
<p>We will use these : <code>use socket2::{Domain, Protocol, SockAddr, Socket, Type};</code>.</p>
<h4 id="Step-1-Bind"><a href="#Step-1-Bind" class="headerlink" title="Step 1: Bind"></a>Step 1: Bind</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(unix)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bind_multicast</span></span>(socket: &amp;Socket, addr: &amp;SocketAddr) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    socket.bind(&amp;socket2::SockAddr::from(*addr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The binding method is different from Windows and *nix, that, in Windows, </p>
<p><a href="https://docs.microsoft.com/zh-tw/windows/desktop/api/winsock/nf-winsock-bind" target="_blank" rel="noopener">https://docs.microsoft.com/zh-tw/windows/desktop/api/winsock/nf-winsock-bind</a> mentions:</p>
<blockquote>
<p>For multicast operations, the preferred method is to call the bind function to associate a socket with a local IP address and then join the multicast group. Although this order of operations is not mandatory, it is strongly recommended. So a multicast application would first select an IPv4 or IPv6 address on the local computer, the wildcard IPv4 address (INADDR_ANY), or the wildcard IPv6 address (in6addr_any). The the multicast application would then call the bind function with this address in the in the sa_data member of the name parameter to associate the local IP address with the socket. If a wildcard address was specified, then Windows will select the local IP address to use. After the bind function completes, an application would then join the multicast group of interest. For more information on how to join a multicast group, see the section on Multicast Programming. This socket can then be used to receive multicast packets from the multicast group using the recv, recvfrom, WSARecv, WSARecvEx, WSARecvFrom, or WSARecvMsg functions.</p>
</blockquote>
<p>In short, we need a <code>INADDR_ANY</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(windows)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bind_multicast</span></span>(socket: &amp;Socket, addr: &amp;SocketAddr) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> addr = <span class="keyword">match</span> *addr &#123;</span><br><span class="line">        SocketAddr::V4(addr) =&gt; SocketAddr::new(Ipv4Addr::new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).into(), addr.port()),</span><br><span class="line">        SocketAddr::V6(addr) =&gt; &#123;</span><br><span class="line">            SocketAddr::new(Ipv6Addr::new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).into(), addr.port())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.bind(&amp;socket2::SockAddr::from(addr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Step-2-Join"><a href="#Step-2-Join" class="headerlink" title="Step 2: Join"></a>Step 2: Join</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">join_multicast</span></span>(addr: SocketAddr) -&gt; io::<span class="built_in">Result</span>&lt;UdpSocket&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> ip_addr = addr.ip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> socket = new_socket(&amp;addr)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// depending on the IP protocol we have slightly different work</span></span><br><span class="line">    <span class="keyword">match</span> ip_addr &#123;</span><br><span class="line">        IpAddr::V4(<span class="keyword">ref</span> mdns_v4) =&gt; &#123;</span><br><span class="line">            <span class="comment">// join to the multicast address, with all interfaces</span></span><br><span class="line">            socket.join_multicast_v4(mdns_v4, &amp;Ipv4Addr::new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))?;</span><br><span class="line">        &#125;</span><br><span class="line">        IpAddr::V6(<span class="keyword">ref</span> mdns_v6) =&gt; &#123;</span><br><span class="line">            <span class="comment">// join to the multicast address, with all interfaces (ipv6 uses indexes not addresses)</span></span><br><span class="line">            socket.join_multicast_v6(mdns_v6, <span class="number">0</span>)?;</span><br><span class="line">            socket.set_only_v6(<span class="literal">true</span>)?;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind us to the socket address.</span></span><br><span class="line">    bind_multicast(&amp;socket, &amp;addr)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert to standard sockets</span></span><br><span class="line">    <span class="literal">Ok</span>(socket.into_udp_socket())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Step-3-Listener-and-Sender"><a href="#Step-3-Listener-and-Sender" class="headerlink" title="Step 3: Listener and Sender"></a>Step 3: Listener and Sender</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multicast_listener</span></span>(</span><br><span class="line">    response: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    client_done: Arc&lt;AtomicBool&gt;,</span><br><span class="line">    addr: SocketAddr,</span><br><span class="line">) -&gt; JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// A barrier to not start the client test code until after the server is running</span></span><br><span class="line">    <span class="keyword">let</span> server_barrier = Arc::new(Barrier::new(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">let</span> client_barrier = Arc::clone(&amp;server_barrier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> join_handle = std::thread::Builder::new()</span><br><span class="line">        .name(<span class="built_in">format!</span>(<span class="string">"&#123;&#125;:server"</span>, response))</span><br><span class="line">        .spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// socket creation will go here...</span></span><br><span class="line">            <span class="keyword">let</span> listener = join_multicast(addr).expect(<span class="string">"failed to create listener"</span>);</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:server: joined: &#123;&#125;"</span>, response, addr);</span><br><span class="line"></span><br><span class="line">            server_barrier.wait();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:server: is ready"</span>, response);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We'll be looping until the client indicates it is done.</span></span><br><span class="line">            <span class="keyword">while</span> !client_done.load(std::sync::atomic::Ordering::Relaxed) &#123;</span><br><span class="line">                <span class="comment">// test receive and response code will go here...</span></span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0u8</span>; <span class="number">64</span>]; <span class="comment">// receive buffer</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// we're assuming failures were timeouts, the client_done loop will stop us</span></span><br><span class="line">                <span class="keyword">match</span> listener.recv_from(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">                    <span class="literal">Ok</span>((len, remote_addr)) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">let</span> data = &amp;buf[..len];</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">println!</span>(</span><br><span class="line">                            <span class="string">"&#123;&#125;:server: got data: &#123;&#125; from: &#123;&#125;"</span>,</span><br><span class="line">                            response,</span><br><span class="line">                            <span class="built_in">String</span>::from_utf8_lossy(data),</span><br><span class="line">                            remote_addr</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// create a socket to send the response</span></span><br><span class="line">                        <span class="keyword">let</span> responder = new_socket(&amp;remote_addr)</span><br><span class="line">                            .expect(<span class="string">"failed to create responder"</span>)</span><br><span class="line">                            .into_udp_socket();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// we send the response that was set at the method beginning</span></span><br><span class="line">                        responder</span><br><span class="line">                            .send_to(response.as_bytes(), &amp;remote_addr)</span><br><span class="line">                            .expect(<span class="string">"failed to respond"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:server: sent response to: &#123;&#125;"</span>, response, remote_addr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="literal">Err</span>(err) =&gt; &#123;</span><br><span class="line">                        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:server: got an error: &#123;&#125;"</span>, response, err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:server: client is done"</span>, response);</span><br><span class="line">        &#125;)</span><br><span class="line">        .unwrap();</span><br><span class="line"></span><br><span class="line">    client_barrier.wait();</span><br><span class="line">    join_handle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_sender</span></span>(addr: &amp;SocketAddr) -&gt; io::<span class="built_in">Result</span>&lt;UdpSocket&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> socket = new_socket(addr)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> addr.is_ipv4() &#123;</span><br><span class="line">        socket.set_multicast_if_v4(&amp;Ipv4Addr::new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))?;</span><br><span class="line"></span><br><span class="line">        socket.bind(&amp;SockAddr::from(SocketAddr::new(</span><br><span class="line">            Ipv4Addr::new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).into(),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">        )))?;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// *WARNING* THIS IS SPECIFIC TO THE AUTHORS COMPUTER</span></span><br><span class="line">        <span class="comment">//   find the index of your IPv6 interface you'd like to test with.</span></span><br><span class="line">        socket.set_multicast_if_v6(<span class="number">5</span>)?;</span><br><span class="line"></span><br><span class="line">        socket.bind(&amp;SockAddr::from(SocketAddr::new(</span><br><span class="line">            Ipv6Addr::new(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>).into(),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">        )))?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert to standard sockets...</span></span><br><span class="line">    <span class="literal">Ok</span>(socket.into_udp_socket())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Step-4-Using-Listener-and-Sender"><a href="#Step-4-Using-Listener-and-Sender" class="headerlink" title="Step 4: Using Listener and Sender"></a>Step 4: Using Listener and Sender</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_multicast</span></span>(test: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>, addr: IpAddr) &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(addr.is_multicast());</span><br><span class="line">    <span class="keyword">let</span> addr = SocketAddr::new(addr, PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> client_done = Arc::new(AtomicBool::new(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> notify = NotifyServer(Arc::clone(&amp;client_done));</span><br><span class="line"></span><br><span class="line">    multicast_listener(test, client_done, addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client test code send and receive code after here</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:client: running"</span>, test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">b"Hello from client!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the sending socket</span></span><br><span class="line">    <span class="keyword">let</span> socket = new_sender(&amp;addr).expect(<span class="string">"could not create sender!"</span>);</span><br><span class="line">    socket.send_to(message, &amp;addr).expect(<span class="string">"could not send_to!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = [<span class="number">0u8</span>; <span class="number">64</span>]; <span class="comment">// receive buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> socket.recv_from(&amp;<span class="keyword">mut</span> buf) &#123;</span><br><span class="line">        <span class="literal">Ok</span>((len, remote_addr)) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> data = &amp;buf[..len];</span><br><span class="line">            <span class="keyword">let</span> response = <span class="built_in">String</span>::from_utf8_lossy(data);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:client: got data: &#123;&#125;"</span>, test, response);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// verify it's what we expected</span></span><br><span class="line">            <span class="built_in">assert_eq!</span>(test, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;:client: had a problem: &#123;&#125;"</span>, test, err);</span><br><span class="line">            <span class="built_in">assert!</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure we don't notify the server until the end of the client test</span></span><br><span class="line">    <span class="built_in">drop</span>(notify);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Comparing to C++ clients and servers. std libraries in Rust is much simpler, but to write codes with greater control, Rust is quite verbose but still very readable in comparison.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.abby.md/2019/05/16/multicasting-in-rust/" data-id="cjvrt1dak0003bcostc8nkal0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust-ipv4-ipv6-multicast-udp/">Rust,ipv4,ipv6,multicast,udp</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rust-ipv4-ipv6-multicast-udp/">Rust,ipv4,ipv6,multicast,udp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nom-Rust-parser-json-nom5/">nom,Rust,parser,json,nom5</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Rust-ipv4-ipv6-multicast-udp/" style="font-size: 10px;">Rust,ipv4,ipv6,multicast,udp</a> <a href="/tags/nom-Rust-parser-json-nom5/" style="font-size: 10px;">nom,Rust,parser,json,nom5</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/17/How-does-nom-work/">How does nom v.5 work?</a>
          </li>
        
          <li>
            <a href="/2019/05/16/multicasting-in-rust/">Multicasting in Rust</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Abby Chau<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>