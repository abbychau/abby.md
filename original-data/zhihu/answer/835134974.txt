PHP 的协程化是什么意思？
<p>1. 因为协程是共用同一进程的，如果不修改，则会引起堵塞。<br><br>2. 理论上来说，协程的并发是软时间分片，而如何分片则是Reactor 和它的上层实现来解決的。<br><br>方法上都是把客户端重写一次。<br>以已经能使用协程的curl / mysql / redis 三个协定为例。<br><br>因为Swoole 早完成了swoole_http_client_coro 的http 客户端，所以把Curl 的接口重定向一次就完了。<br>也就是说, 你在写go() 时看见的curl_* ，其实是在利用swoole_http_client_coro。<br><br>而swoole_mysql_coro 则是基于mysqlnd, 以 `swoole::coroutine::Socket;` 发起连接。<br><a href="http://link.zhihu.com/?target=https%3A//github.com/swoole/swoole-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_mysql_coro.cc%23L760%3A20" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/swoole/swool</span><span class="invisible">e-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_mysql_coro.cc#L760:20</span><span class="ellipsis"></span></a><br><br>而redis 则是利用 hiredis + `swoole::coroutine::Socket;` , socket 是交回全局的SwooleTG.reactor 管理的。<br><a href="http://link.zhihu.com/?target=https%3A//github.com/swoole/swoole-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_redis_coro.cc%23L1248%3A13" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/swoole/swool</span><span class="invisible">e-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_redis_coro.cc#L1248:13</span><span class="ellipsis"></span></a></p><p>而co::exec() 则是利用 sh 对命令产生一个新的fd 再用`swoole::coroutine::Socket;`循环读取<br><a href="http://link.zhihu.com/?target=https%3A//github.com/swoole/swoole-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_coroutine_system.cc%23L798" class=" external" target="_blank" rel="nofollow noreferrer"><span class="invisible">https://</span><span class="visible">github.com/swoole/swool</span><span class="invisible">e-src/blob/c9fb157f4dadbb8de70004430a587cdc2c8a7c15/swoole_coroutine_system.cc#L798</span><span class="ellipsis"></span></a><br>可见在Swoole 中的Socket 十分重要。</p><p><br>3. 如果在类中有出现过挂起线程的动作，那就一定要修改了。如果有堵塞，则会令并发失效。</p>
1569390080